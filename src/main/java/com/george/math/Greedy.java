package com.george.math;

/**
 * Created by George on 2017/9/20.
 *
 * 贪心算法适用于通过局部最优选择出全局最优，贪心算法的应用压缩编码
 * 活动选择问题描述：每个活动ai有开始时间si和结束时间fi，因此存在区间[si,fi)，若另外一个活动aj的开始时间sj和结束时间fj，则存在区间[sj,fj)若si>=fj或者sj>=fi则说明活动ai与aj兼容，此问题是找出相互兼容活动的最大集合
 *
 * 设计贪心算法解决问题的步骤：
 * 1.决定问题的最优子结构
 * 2.设计出一个递归解
 * 3.证明在递归的任一阶段，最优选择之一总是贪心选择
 * 4.证明通过做贪心选择，所有子问题都为空
 * 5.设计出一个实现贪心策略的递归算法
 * 6.将递归算法转换成迭代算法
 *
 * 贪心选择性质与最优子结构是两个关键点：
 * 1）贪心选择性质：一个全局最优解可以通过局部最优选择达到，只考虑当前问题的最佳选择，贪心策略通常是自顶向下的做，必须证明每一步的贪心选择可以最终产生全局最优解
 *
 * 2）最优子结构比如（Sij）：对于一个问题而言，如果一个最优解包含了其子问题的最优解
 *
 * 贪心算法解决的最经典问题背包问题：小偷在背包容量已经W的前提下，想要尽可能装更值钱的东西，比如有东西i，其价值为vi,其重量为wi
 * 0-1背包问题和部分背包问题的区别在于后者小偷可以选择只拿走东西i的部分，下次选择可以是n-1个商品或者是wi-w的商品，部分背包问题适用于贪心算法
 *
 * 0-1背包问题利用动态规划解决：
 * 1）描述问题的最优解（寻找最优子结构），最优即容量有限的前提下总价值最高，c[i][m](前i个商品中能装入背包为m容量的最大价值)
 * 2）递归定义最优解的值
 * c[i][m]=0 i=0 || m=0
 * c[i][m]=c[i-1][m] w[i]>m,即第i件商品质量超过剩余承重（放不下）
 * c[i][m]=max{c[i-1][m](不放第i件商品),c[i-1][m-w[i]]+v[i]（放第i件商品)}
 * 3）自底向上计算最优解
 * 4)构造最优解
 *
 */
public class Greedy { //贪心算法
    public static void main(String[] args){
       int w[]=new int[]{0,3,5,2,6,4};
        int v[]=new int[]{0,4,4,3,5,3};
        int c[][]=new int[6][13];
        int path[][]=new int[6][13];
        Greedy greedy=new Greedy();
        greedy.zeroOneBag(w,v,c,5,12,path);
        for(int i=1;i<=5;i++){
            for(int j=1;j<=12;j++){
                System.out.print(c[i][j]+" ");
            }
            System.out.println();
        }
    }
    public void zeroOneBag(int w[],int v[],int c[][],int n,int m,int path[][]){
        for(int j=1;j<=n;j++){
            c[j][0]=0;
        }
        for(int j=1;j<=m;j++){
            c[0][j]=0;
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(w[i]>j){  //放不下商品i
                    c[i][j]=c[i-1][j];
                }
                else{
                    if(c[i-1][j]<c[i-1][j-w[i]]+v[i]){
                        c[i][j]=c[i-1][j-w[i]]+v[i];
                        path[i][j]=1;
                    }
                    else{
                        c[i][j]=c[i-1][j];
                    }
                }
            }
        }

    }
}
